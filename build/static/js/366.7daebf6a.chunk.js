(self.webpackChunkpolkasafe_ui=self.webpackChunkpolkasafe_ui||[]).push([[366,848,833,827],{44879:(t,i,n)=>{"use strict";n.d(i,{v:()=>o});var e=n(46622),s=n(27994),a=n.n(s);class o extends e.J5{async init(t){this.chainConfig||(this.chainConfig=(0,e.h2)(e.EN.SOLANA,1))}async authenticateUser(){if(!this.provider||this.status!==e.MP.CONNECTED)throw e.RM.notConnectedError();const{chainNamespace:t,chainId:i}=this.chainConfig,n=await this.provider.request({method:"getAccounts"});if(n&&n.length>0){const s=(0,e.Cb)(n[0],this.name);if(s){if(!(0,e.$E)(s))return{idToken:s}}const o={domain:window.location.origin,uri:window.location.href,address:n[0],chainId:parseInt(i,16),version:"1",nonce:Math.random().toString(36).slice(2),issuedAt:(new Date).toISOString()},r=await(0,e.tV)(o,t),h=(new TextEncoder).encode(r),c=await this.provider.request({method:"signMessage",params:{message:h,display:"utf8"}}),l=await(0,e.rn)(t,a().encode(c),r,this.name,this.sessionTime,this.clientId,this.web3AuthNetwork);return(0,e.Fr)(n[0],this.name,l),{idToken:l}}throw e.RM.notConnectedError("Not connected with wallet, Please login/connect first")}async disconnectSession(){super.checkDisconnectionRequirements();const t=await this.provider.request({method:"getAccounts"});t&&t.length>0&&(0,e.qz)(t[0],this.name)}async disconnect(){this.rehydrated=!1,this.emit(e.n2.DISCONNECTED)}}},76392:(t,i,n)=>{"use strict";n.d(i,{PhantomAdapter:()=>c});var e=n(20240),s=n(46622),a=n(44879),o=n(47703);function r(t,i,n){return new Promise(((e,s)=>{n>0?setTimeout((async()=>{const a=await t();a&&e(a),a||r(t,i,n-1).then((t=>(e(t),t))).catch((t=>s(t)))}),i):e(!1)}))}const h=async function(){var t;let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{interval:1e3,count:3};if("undefined"!==typeof window&&!(null===(t=window.solana)||void 0===t||!t.isPhantom))return window.solana;return await r((()=>{var t;return null===(t=window.solana)||void 0===t?void 0:t.isPhantom}),i.interval,i.count)?window.solana:null};class c extends a.v{constructor(){super(...arguments),(0,e.Z)(this,"name",s.rW.PHANTOM),(0,e.Z)(this,"adapterNamespace",s.yk.SOLANA),(0,e.Z)(this,"currentChainNamespace",s.EN.SOLANA),(0,e.Z)(this,"type",s.hN.EXTERNAL),(0,e.Z)(this,"status",s.MP.NOT_READY),(0,e.Z)(this,"_wallet",null),(0,e.Z)(this,"phantomProvider",null),(0,e.Z)(this,"_onDisconnect",(()=>{this._wallet&&(this._wallet.off("disconnect",this._onDisconnect),this.rehydrated=!1,this.status=this.status===s.MP.CONNECTED?s.MP.READY:s.MP.NOT_READY,this.emit(s.n2.DISCONNECTED))}))}get isWalletConnected(){var t;return!(null===(t=this._wallet)||void 0===t||!t.isConnected||this.status!==s.MP.CONNECTED)}get provider(){var t;return(null===(t=this.phantomProvider)||void 0===t?void 0:t.provider)||null}set provider(t){throw new Error("Not implemented")}async init(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(await super.init(t),super.checkInitializationRequirements(),this._wallet=await h({interval:500,count:3}),!this._wallet)throw s.Ty.notInstalled();this.phantomProvider=new o.kL({config:{chainConfig:this.chainConfig}}),this.status=s.MP.READY,this.emit(s.n2.READY,s.rW.PHANTOM);try{s.cM.debug("initializing phantom adapter"),t.autoConnect&&(this.rehydrated=!0,await this.connect())}catch(i){s.cM.error("Failed to connect with cached phantom provider",i),this.emit("ERRORED",i)}}async connect(){var t=this;try{if(super.checkConnectionRequirements(),this.status=s.MP.CONNECTING,this.emit(s.n2.CONNECTING,{adapter:s.rW.PHANTOM}),!this._wallet)throw s.Ty.notInstalled();if(this._wallet.isConnected)await this.connectWithProvider(this._wallet);else{const n=this._wallet._handleDisconnect;try{await new Promise(((i,e)=>{this._wallet?(this._wallet.once("connect",(async()=>{await this.connectWithProvider(this._wallet),i(this.provider)})),this._wallet._handleDisconnect=function(){e(s.Ty.windowClosed());for(var i=arguments.length,a=new Array(i),o=0;o<i;o++)a[o]=arguments[o];return n.apply(t._wallet,a)},this._wallet.connect().catch((t=>{e(t)}))):e(s.Ty.notInstalled())}))}catch(i){if(i instanceof s.up)throw i;throw s.RM.connectionError(null===i||void 0===i?void 0:i.message)}finally{this._wallet._handleDisconnect=n}}if(!this._wallet.publicKey)throw s.RM.connectionError();return this._wallet.on("disconnect",this._onDisconnect),this.provider}catch(i){throw this.status=s.MP.READY,this.rehydrated=!1,this.emit(s.n2.ERRORED,i),i}}async disconnect(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{cleanup:!1};await super.disconnectSession();try{var i;await(null===(i=this._wallet)||void 0===i?void 0:i.disconnect()),t.cleanup&&(this.status=s.MP.NOT_READY,this.phantomProvider=null,this._wallet=null),await super.disconnect()}catch(n){this.emit(s.n2.ERRORED,s.RM.disconnectionError(null===n||void 0===n?void 0:n.message))}}async getUserInfo(){if(!this.isWalletConnected)throw s.RM.notConnectedError("Not connected with wallet, Please login/connect first");return{}}async addChain(t){var i;let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.checkAddChainRequirements(n),null===(i=this.phantomProvider)||void 0===i||i.addChain(t),this.addChainConfig(t)}async switchChain(t){var i;let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.checkSwitchChainRequirements(t,n),await(null===(i=this.phantomProvider)||void 0===i?void 0:i.switchChain(t)),this.setAdapterSettings({chainConfig:this.getChainConfig(t.chainId)})}async connectWithProvider(t){if(!this.phantomProvider)throw s.RM.connectionError("No phantom provider");return await this.phantomProvider.setupProvider(t),this.status=s.MP.CONNECTED,this.emit(s.n2.CONNECTED,{adapter:s.rW.PHANTOM,reconnected:this.rehydrated}),this.provider}}},78848:()=>{}}]);
//# sourceMappingURL=366.7daebf6a.chunk.js.map